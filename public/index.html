<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Drift - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; }
        
        /* LOGIN SCREEN */
        #loginOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 10;
        }
        #loginBox {
            background: #fff; padding: 30px; border-radius: 10px; text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        input { padding: 10px; font-size: 1.2rem; width: 200px; margin-bottom: 15px; border: 2px solid #ccc; border-radius: 5px; }
        button { padding: 10px 20px; font-size: 1.2rem; background: #ff0044; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #d00033; }

        /* HUD */
        #speedometer {
            position: absolute; bottom: 20px; left: 20px; color: #fff;
            font-size: 2.5rem; font-family: monospace; font-weight: bold;
            text-shadow: 2px 2px 0px #000;
        }

        /* SETTINGS PANEL */
        #settings {
            position: absolute; top: 20px; right: 20px; width: 200px;
            background: rgba(0, 0, 0, 0.7); color: white; padding: 15px;
            border-radius: 10px; backdrop-filter: blur(5px); font-family: sans-serif;
            font-size: 0.9rem;
        }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .control-group input[type=range] { width: 100%; }
        .control-group span { font-size: 0.8rem; color: #aaa; float: right; }
    </style>
</head>
<body>

    <div id="loginOverlay">
        <div id="loginBox">
            <h1>Drift City</h1>
            <p>Enter your racer name:</p>
            <input type="text" id="playerNameInput" placeholder="Your Name" maxlength="10">
            <br>
            <p style="margin-top: 15px;">Select Game Mode:</p>
            <select id="gameModeSelect" style="padding: 8px; font-size: 1rem; margin-bottom: 15px;">
                <option value="freeplay">Free Play (Drift & Explore)</option>
                <option value="tag">Tag (Chase & Tag Others)</option>
                <option value="shooting">Shooting (Combat Mode)</option>
            </select>
            <br>
            <button onclick="startGame()">JOIN GAME</button>
        </div>
    </div>

    <div id="speedometer">0 km/h</div>
    
    <!-- Game Mode HUD -->
    <div id="gameHUD" style="position: absolute; top: 20px; left: 20px; display: none;">
        <!-- Tag Mode HUD -->
        <div id="tagHUD" style="display: none; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; color: white;">
            <h3 style="margin: 0 0 10px 0; color: #ff4444;">üèÉ TAG MODE</h3>
            <div id="tagStatus">You are: <span style="color: #44ff44;">Safe</span></div>
            <div style="font-size: 0.8rem; margin-top: 5px;">Chase and tag other players!</div>
        </div>
        
        <!-- Shooting Mode HUD -->
        <div id="shootingHUD" style="display: none; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; color: white;">
            <h3 style="margin: 0 0 10px 0; color: #ff4444;">üéØ SHOOTING MODE</h3>
            <div>Kills: <span id="killCount" style="color: #44ff44; font-weight: bold;">0</span></div>
            <div>Deaths: <span id="deathCount" style="color: #ff4444; font-weight: bold;">0</span></div>
            <div style="font-size: 0.8rem; margin-top: 5px;">Press SPACE to shoot</div>
        </div>
    </div>
    
    <!-- Death/Respawn Overlay -->
    <div id="deathOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 5;">
        <div style="background: #fff; padding: 40px; border-radius: 15px; text-align: center;">
            <h2 style="color: #ff0044; margin: 0 0 20px 0;">üíÄ YOU DIED!</h2>
            <p style="font-size: 1.2rem; margin-bottom: 20px;">Your kills have been reset</p>
            <button onclick="respawn()" style="padding: 15px 30px; font-size: 1.2rem; background: #44ff44; color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                RESPAWN
            </button>
        </div>
    </div>

    <div id="settings">
        <h3 style="margin-top:0; border-bottom:1px solid #555; padding-bottom:5px;">Performance</h3>
        
        <div class="control-group">
            <label>Smoke Amount <span id="smokeVal">50%</span></label>
            <input type="range" id="smokeSlider" min="0" max="100" value="50">
        </div>

        <div class="control-group">
            <label style="display:flex; justify-content:space-between; cursor:pointer;">
                Shadows
                <input type="checkbox" id="shadowToggle" checked>
            </label>
        </div>
        
        <div style="font-size:0.7rem; color:#888; margin-top:10px;">
            Tire marks removed for speed.
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Config ---
        const CONFIG = {
            maxSpeed: 2.0, acceleration: 0.035, friction: 0.98, turnSpeed: 0.045,
            driftFactor: 0.94, cameraHeight: 15, cameraDistance: 25, cameraLerp: 0.1,
            mapSize: 400
        };

        // --- Globals ---
        let scene, camera, renderer, socket;
        let car, carVelocity = new THREE.Vector3();
        let inputs = { up: false, down: false, left: false, right: false, space: false };
        let particles = [];
        let bullets = [];
        let speed = 0;
        let carHeading = 0;
        let otherPlayers = {}; 
        let dirLight;
        let myName = "Player";
        let isGameActive = false;
        let currentGameMode = 'freeplay';
        
        // Game mode stats
        let kills = 0;
        let deaths = 0;
        window.isIt = false; // For tag mode
        let canShoot = true;
        let shootCooldown = 500; // ms between shots

        let SETTINGS = {
            smokeChance: 0.5,
            shadows: true
        };
        
        const dummyObj = new THREE.Object3D(); 

        // Expose startGame to HTML button
        window.startGame = function() {
            const nameInput = document.getElementById('playerNameInput');
            const modeSelect = document.getElementById('gameModeSelect');
            
            if(nameInput.value.trim() !== "") {
                myName = nameInput.value.trim();
                currentGameMode = modeSelect.value;
                
                document.getElementById('loginOverlay').style.display = 'none';
                isGameActive = true;
                
                // Show appropriate HUD
                document.getElementById('gameHUD').style.display = 'block';
                if(currentGameMode === 'tag') {
                    document.getElementById('tagHUD').style.display = 'block';
                } else if(currentGameMode === 'shooting') {
                    document.getElementById('shootingHUD').style.display = 'block';
                }
                
                // If socket is ready, send name and mode
                if(socket) {
                    socket.emit('joinGame', { name: myName, gameMode: currentGameMode });
                    // Add my own name tag
                    addNameTag(car, myName, true);
                }
            } else {
                alert("Please enter a name!");
            }
        };
        
        window.respawn = function() {
            document.getElementById('deathOverlay').style.display = 'none';
            kills = 0;
            document.getElementById('killCount').innerText = kills;
            
            // Reset position
            car.position.set(Math.random() * 100 - 50, 0, Math.random() * 100 - 50);
            carVelocity.set(0, 0, 0);
            speed = 0;
            
            if(socket) {
                socket.emit('respawn');
            }
        };

        init();
        animate();

        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 60, 300);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 2. Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 100, 0);
            scene.add(hemiLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(80, 120, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024; 
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 400;
            const d = 150;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            scene.add(dirLight);

            // 3. World
            createParkingLot();
            createCityBorderOptimized();
            createCar(); // Creates MY car

            // 4. Events
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => { if(isGameActive) handleKey(e, true) });
            document.addEventListener('keyup', (e) => { if(isGameActive) handleKey(e, false) });
            setupUISettings();

            initSocket();
        }

        // --- NAME TAG SYSTEM ---
        function createTextSprite(message) {
            const fontface = "Arial";
            const fontsize = 40;
            const borderThickness = 4;
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256; // Power of 2 for GPU
            canvas.height = 128;
            
            context.font = "Bold " + fontsize + "px " + fontface;
            
            // Text Width
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            
            // Background
            context.fillStyle = "rgba(0,0,0,0.5)";
            context.strokeStyle = "rgba(0,0,0,0.5)";
            context.lineWidth = borderThickness;
            
            // Centered Rect
            const x = (canvas.width - textWidth) / 2 - 10;
            const y = (canvas.height - fontsize) / 2;
            const w = textWidth + 20;
            const h = fontsize * 1.4;
            
            roundRect(context, x, y, w, h, 6); // Helper function below
            
            // Text
            context.fillStyle = "rgba(255, 255, 255, 1.0)";
            context.textAlign = "center";
            context.fillText(message, canvas.width/2, (canvas.height + fontsize/2)/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            // Scale sprite to be reasonable size in 3D world
            sprite.scale.set(10, 5, 1);
            return sprite;
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x+r, y);
            ctx.lineTo(x+w-r, y);
            ctx.quadraticCurveTo(x+w, y, x+w, y+r);
            ctx.lineTo(x+w, y+h-r);
            ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
            ctx.lineTo(x+r, y+h);
            ctx.quadraticCurveTo(x, y+h, x, y+h-r);
            ctx.lineTo(x, y+r);
            ctx.quadraticCurveTo(x, y, x+r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function addNameTag(targetObj, name, isMe) {
            // Remove old tag if exists
            const oldTag = targetObj.getObjectByName("NameTag");
            if(oldTag) targetObj.remove(oldTag);

            const sprite = createTextSprite(name);
            sprite.position.set(0, 3.5, 0); // 3.5 units above car center
            sprite.name = "NameTag";
            
            if(isMe) sprite.material.color.setHex(0xffff00); // Yellow name for self

            targetObj.add(sprite);
        }

        // --- GAME LOGIC ---

        function setupUISettings() {
            const smokeSlider = document.getElementById('smokeSlider');
            const smokeVal = document.getElementById('smokeVal');
            smokeSlider.addEventListener('input', (e) => {
                SETTINGS.smokeChance = e.target.value / 100;
                smokeVal.innerText = e.target.value + '%';
            });

            const shadowToggle = document.getElementById('shadowToggle');
            shadowToggle.addEventListener('change', (e) => {
                SETTINGS.shadows = e.target.checked;
                renderer.shadowMap.enabled = SETTINGS.shadows;
                dirLight.castShadow = SETTINGS.shadows;
                scene.traverse((child) => { if (child.material) child.material.needsUpdate = true; });
            });
        }

        function initSocket() {
            socket = io();
            
            socket.on('currentPlayers', (players) => {
                Object.keys(players).forEach((id) => {
                    if (id !== socket.id) addOtherPlayer(players[id], id);
                });
            });

            socket.on('newPlayer', (data) => {
                addOtherPlayer(data.player, data.id);
            });

            socket.on('updatePlayerName', (data) => {
                if(data.id === socket.id) {
                    addNameTag(car, data.name, true);
                } else if(otherPlayers[data.id]) {
                    addNameTag(otherPlayers[data.id].mesh, data.name, false);
                }
            });

            socket.on('playerMoved', (data) => {
                if (otherPlayers[data.id]) {
                    otherPlayers[data.id].targetX = data.x;
                    otherPlayers[data.id].targetY = data.y || 0;
                    otherPlayers[data.id].targetZ = data.z;
                    otherPlayers[data.id].targetAngle = data.angle;
                    otherPlayers[data.id].isDrifting = data.isDrifting; 
                }
            });

            socket.on('playerDisconnected', (id) => {
                if (otherPlayers[id]) { scene.remove(otherPlayers[id].mesh); delete otherPlayers[id]; }
            });
            
            // Tag mode events
            socket.on('tagUpdate', (data) => {
                if(data.tagger === socket.id) {
                    window.isIt = false;
                    document.getElementById('tagStatus').innerHTML = 'You are: <span style="color: #44ff44;">Safe</span>';
                } else if(data.tagged === socket.id) {
                    window.isIt = true;
                    document.getElementById('tagStatus').innerHTML = 'You are: <span style="color: #ff4444;">IT!</span>';
                }
                
                // Update other player colors
                if(otherPlayers[data.tagged]) {
                    otherPlayers[data.tagged].isIt = true;
                }
                if(otherPlayers[data.tagger]) {
                    otherPlayers[data.tagger].isIt = false;
                }
            });
            
            // Shooting mode events
            socket.on('playerShot', (data) => {
                // Create bullet from other player
                const bulletGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
                const bullet = new THREE.Mesh(bulletGeo, bulletMat);
                bullet.position.set(data.x, data.y, data.z);
                scene.add(bullet);
                
                bullets.push({
                    mesh: bullet,
                    vel: { x: data.velX, z: data.velZ },
                    ownerId: data.playerId,
                    life: 100
                });
            });
            
            socket.on('playerHit', (data) => {
                if(data.victim === socket.id) {
                    // I got hit!
                    deaths++;
                    document.getElementById('deathCount').innerText = deaths;
                    document.getElementById('deathOverlay').style.display = 'flex';
                }
            });
        }

        function addOtherPlayer(data, id) {
            const playerGroup = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4), new THREE.MeshStandardMaterial({ color: data.color || 0xcccccc }));
            body.position.y = 0.6; body.castShadow = true; playerGroup.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            cabin.position.set(0, 1.2, -0.2); cabin.castShadow = true; playerGroup.add(cabin);
            
            playerGroup.position.set(data.x, data.y || 0, data.z);
            scene.add(playerGroup);
            
            // Add name tag immediately
            addNameTag(playerGroup, data.name || "Racer", false);

            otherPlayers[id] = { 
                mesh: playerGroup, 
                targetX: data.x, 
                targetY: data.y || 0,
                targetZ: data.z, 
                targetAngle: data.angle, 
                isDrifting: false 
            };
        }

        function createTiledGroundTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Base tile color
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, 128, 128);
            
            // Tile grid lines
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            
            // Draw grid
            for(let i = 0; i <= 4; i++) {
                ctx.beginPath();
                ctx.moveTo(i * 32, 0);
                ctx.lineTo(i * 32, 128);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * 32);
                ctx.lineTo(128, i * 32);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50);
            return texture;
        }

        function createParkingLot() {
            // Main tiled ground
            const groundTexture = createTiledGroundTexture();
            const groundGeo = new THREE.PlaneGeometry(CONFIG.mapSize, CONFIG.mapSize);
            const groundMat = new THREE.MeshStandardMaterial({ 
                map: groundTexture,
                roughness: 0.8, 
                metalness: 0.1 
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create the map layout
            // Map grid: 5x5 sections, each section is 80 units to fill the map better
            const sectionSize = 80;
            const platformHeight = 15;
            const platformThickness = platformHeight; // Make it a solid block
            
            // Map layout based on emoji grid:
            // üü¶üü¶üü¶üü¶üü¶  (top platforms in corners)
            // üü•‚¨õ‚¨õ‚¨õüü•  (ramps on sides)
            // ‚¨õ‚¨õ‚¨õ‚¨õ‚¨õ  (center ground)
            // üü•‚¨õ‚¨õ‚¨õüü•  (ramps on sides)
            // üü¶üü¶üü¶üü¶üü¶  (bottom platforms in corners)
            
            const mapLayout = [
                ['P','P','P','P','P'], // top row - platforms
                ['R','G','G','G','R'], // ramps on sides
                ['G','G','G','G','G'], // center ground
                ['R','G','G','G','R'], // ramps on sides
                ['P','P','P','P','P']  // bottom row - platforms
            ];

            // Store platform and ramp collision boxes
            window.gameColliders = [];

            // Concrete colors
            const platformColor = 0x8899aa; // Light gray-blue concrete
            const rampColor = 0x999999; // Gray concrete
            
            // Create platforms (üü¶) - SOLID filled blocks
            const platformGeo = new THREE.BoxGeometry(sectionSize, platformThickness, sectionSize);
            const platformMat = new THREE.MeshStandardMaterial({ 
                color: platformColor,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Build the map
            for(let row = 0; row < 5; row++) {
                for(let col = 0; col < 5; col++) {
                    const type = mapLayout[row][col];
                    const x = (col - 2) * sectionSize; // center the map
                    const z = (row - 2) * sectionSize;
                    
                    if(type === 'P') {
                        // Platform - SOLID block from ground to platform height
                        const platform = new THREE.Mesh(platformGeo, platformMat);
                        platform.position.set(x, platformHeight / 2, z); // Center at half height
                        platform.castShadow = true;
                        platform.receiveShadow = true;
                        scene.add(platform);
                        
                        // Store collider info
                        window.gameColliders.push({
                            type: 'platform',
                            minX: x - sectionSize/2,
                            maxX: x + sectionSize/2,
                            minZ: z - sectionSize/2,
                            maxZ: z + sectionSize/2,
                            height: platformHeight,
                            topY: platformHeight
                        });
                        
                        // Add subtle glow effect on top edge
                        const glowLight = new THREE.PointLight(0x6688aa, 10, 30);
                        glowLight.position.set(x, platformHeight + 2, z);
                        scene.add(glowLight);
                        
                    } else if(type === 'R') {
                        // Ramp - SOLID wedge-shaped block
                        const rampWidth = sectionSize;
                        const rampLength = sectionSize;
                        const rampHeight = platformHeight;
                        
                        // Create SOLID wedge geometry
                        const rampGeo = new THREE.BufferGeometry();
                        
                        // Vertices for a SOLID wedge
                        const vertices = new Float32Array([
                            // Bottom face (4 corners)
                            -rampWidth/2, 0, -rampLength/2,  // 0
                            rampWidth/2, 0, -rampLength/2,   // 1
                            rampWidth/2, 0, rampLength/2,    // 2
                            -rampWidth/2, 0, rampLength/2,   // 3
                            
                            // Top edge (2 corners - the high side)
                            -rampWidth/2, rampHeight, -rampLength/2,  // 4
                            rampWidth/2, rampHeight, -rampLength/2,   // 5
                        ]);
                        
                        const indices = [
                            // Bottom face
                            0, 2, 1,
                            0, 3, 2,
                            
                            // Sloped top surface
                            3, 2, 5,
                            3, 5, 4,
                            
                            // Back face (high end)
                            4, 5, 1,
                            4, 1, 0,
                            
                            // Left side
                            0, 3, 4,
                            3, 4, 4,
                            
                            // Right side
                            1, 5, 2,
                            2, 5, 5,
                        ];
                        
                        rampGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                        rampGeo.setIndex(indices);
                        rampGeo.computeVertexNormals();
                        
                        const rampMat = new THREE.MeshStandardMaterial({ 
                            color: rampColor,
                            roughness: 0.8,
                            metalness: 0.1
                        });
                        
                        const ramp = new THREE.Mesh(rampGeo, rampMat);
                        
                        // Determine ramp orientation - ramps should point TOWARD platforms
                        // Top row (row 1) ramps point UP (toward row 0 platforms)
                        // Bottom row (row 3) ramps point DOWN (toward row 4 platforms)
                        if(row === 1) {
                            // Top ramp - high end at north, low end at south
                            ramp.rotation.y = 0; // Face north
                        } else if(row === 3) {
                            // Bottom ramp - high end at south, low end at north
                            ramp.rotation.y = Math.PI; // Face south (flip 180¬∞)
                        }
                        
                        ramp.position.set(x, 0, z);
                        ramp.castShadow = true;
                        ramp.receiveShadow = true;
                        scene.add(ramp);
                        
                        // Store collider info
                        window.gameColliders.push({
                            type: 'ramp',
                            minX: x - sectionSize/2,
                            maxX: x + sectionSize/2,
                            minZ: z - sectionSize/2,
                            maxZ: z + sectionSize/2,
                            row: row,
                            height: platformHeight,
                            length: sectionSize
                        });
                        
                        // Add warning lights on ramps
                        const warnLight = new THREE.PointLight(0xffaa44, 8, 25);
                        warnLight.position.set(x, platformHeight/2 + 3, z);
                        scene.add(warnLight);
                    }
                    // 'G' = ground, already created
                }
            }

            // Light Poles (keep existing lighting)
            const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 15);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const lampGeo = new THREE.BoxGeometry(4, 1, 2);
            const lampMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            
            const polePositions = [{x: 50, z: 50}, {x: -50, z: 50}, {x: 50, z: -50}, {x: -50, z: -50}, {x: 100, z: 0}, {x: -100, z: 0}];
            const poleMesh = new THREE.InstancedMesh(poleGeo, poleMat, polePositions.length);
            const lampMesh = new THREE.InstancedMesh(lampGeo, lampMat, polePositions.length);
            poleMesh.castShadow = true; poleMesh.receiveShadow = true;

            polePositions.forEach((pos, i) => {
                dummyObj.position.set(pos.x, 7.5, pos.z); dummyObj.rotation.set(0,0,0); dummyObj.scale.set(1,1,1); dummyObj.updateMatrix();
                poleMesh.setMatrixAt(i, dummyObj.matrix);
                dummyObj.position.set(pos.x, 15, pos.z); dummyObj.updateMatrix();
                lampMesh.setMatrixAt(i, dummyObj.matrix);
                const pl = new THREE.PointLight(0xffaa00, 30, 50); pl.position.set(pos.x, 14, pos.z); scene.add(pl);
            });
            scene.add(poleMesh); scene.add(lampMesh);
        }

        function createBuildingTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#444'; ctx.fillRect(0, 0, 64, 128);
            ctx.fillStyle = '#8cf'; 
            for(let y=10; y<120; y+=20) { for(let x=10; x<60; x+=20) { if(Math.random() > 0.3) ctx.fillRect(x, y, 10, 15); } }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createCityBorderOptimized() {
            const buildingTex = createBuildingTexture();
            const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
            const buildingMat = new THREE.MeshStandardMaterial({ map: buildingTex, roughness: 0.2 });
            const buildings = new THREE.InstancedMesh(buildingGeo, buildingMat, 200);
            buildings.castShadow = true; buildings.receiveShadow = true;

            let idx = 0;
            const range = CONFIG.mapSize/2 + 20;
            const countPerWall = Math.ceil(CONFIG.mapSize / 40) + 2;
            const addWall = (sx, sz, dx, dz) => {
                for(let i=0; i<countPerWall; i++) {
                    const h = 40 + Math.random() * 80;
                    dummyObj.position.set(sx + (i*dx*40), h/2, sz + (i*dz*40));
                    dummyObj.rotation.set(0,0,0);
                    dummyObj.scale.set(40, h, 40);
                    dummyObj.updateMatrix();
                    buildings.setMatrixAt(idx++, dummyObj.matrix);
                }
            };
            addWall(-range, -range, 1, 0); addWall(-range, range, 1, 0); addWall(range, -range, 0, 1); addWall(-range, -range, 0, 1);
            scene.add(buildings);
        }

        function createCar() {
            car = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4), new THREE.MeshStandardMaterial({ color: 0xff0044 }));
            body.position.y = 0.6; body.castShadow = true; car.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            cabin.position.set(0, 1.2, -0.2); cabin.castShadow = true; car.add(cabin);
            const wGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[-1,0.4,1.2],[1,0.4,1.2],[-1,0.4,-1.2],[1,0.4,-1.2]].forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat); w.rotation.z = Math.PI/2; w.position.set(...p); w.castShadow = true; car.add(w);
            });
            const l = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffaa })); l.position.set(-0.6, 0.7, 2.0); car.add(l);
            const r = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffaa })); r.position.set(0.6, 0.7, 2.0); car.add(r);
            scene.add(car);
        }

        function handleKey(e, pressed) {
            if(e.key === 'ArrowUp') inputs.up = pressed;
            if(e.key === 'ArrowDown') inputs.down = pressed;
            if(e.key === 'ArrowLeft') inputs.left = pressed;
            if(e.key === 'ArrowRight') inputs.right = pressed;
            if(e.key === ' ') {
                inputs.space = pressed;
                if(pressed && currentGameMode === 'shooting' && canShoot) {
                    shootBullet();
                }
            }
        }
        
        function shootBullet() {
            canShoot = false;
            setTimeout(() => { canShoot = true; }, shootCooldown);
            
            // Create bullet
            const bulletGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            // Position bullet at front of car
            const spawnDist = 3;
            bullet.position.set(
                car.position.x + Math.sin(carHeading) * spawnDist,
                car.position.y + 1,
                car.position.z + Math.cos(carHeading) * spawnDist
            );
            
            // Bullet velocity
            const bulletSpeed = 3;
            const bulletVel = {
                x: Math.sin(carHeading) * bulletSpeed,
                z: Math.cos(carHeading) * bulletSpeed
            };
            
            scene.add(bullet);
            bullets.push({
                mesh: bullet,
                vel: bulletVel,
                ownerId: socket.id,
                life: 100 // frames before despawn
            });
            
            // Send to server
            if(socket) {
                socket.emit('shoot', {
                    x: bullet.position.x,
                    y: bullet.position.y,
                    z: bullet.position.z,
                    velX: bulletVel.x,
                    velZ: bulletVel.z
                });
            }
        }
        
        function updateBullets() {
            for(let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.x += b.vel.x;
                b.mesh.position.z += b.vel.z;
                b.life--;
                
                // Check if bullet hits any player
                if(b.ownerId === socket.id && currentGameMode === 'shooting') {
                    Object.keys(otherPlayers).forEach(id => {
                        const other = otherPlayers[id].mesh;
                        const dx = b.mesh.position.x - other.position.x;
                        const dz = b.mesh.position.z - other.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if(dist < 3) {
                            // Hit!
                            scene.remove(b.mesh);
                            bullets.splice(i, 1);
                            
                            kills++;
                            document.getElementById('killCount').innerText = kills;
                            
                            if(socket) {
                                socket.emit('hit', id);
                            }
                            return;
                        }
                    });
                }
                
                // Remove old bullets
                if(b.life <= 0) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(isGameActive) {
                updatePhysics();
                updateMultiplayerCars();
                updateEffects();
                updateBullets();
                updateCamera();
            }
            renderer.render(scene, camera);
        }

        function getGroundHeight(x, z) {
            if(!window.gameColliders) return 0;
            
            // Check each collider
            for(let collider of window.gameColliders) {
                // Check if position is within this collider's bounds
                if(x >= collider.minX && x <= collider.maxX && 
                   z >= collider.minZ && z <= collider.maxZ) {
                    
                    if(collider.type === 'platform') {
                        return collider.height;
                    } else if(collider.type === 'ramp') {
                        // Calculate height based on position on ramp
                        const relZ = z - (collider.minZ + collider.maxZ) / 2;
                        
                        if(collider.row === 1) {
                            // Top ramp - slopes up toward north (negative Z)
                            // At maxZ (south/bottom edge): height = 0
                            // At minZ (north/top edge): height = platformHeight
                            const progress = (collider.maxZ - z) / collider.length;
                            return Math.max(0, Math.min(collider.height, collider.height * progress));
                        } else if(collider.row === 3) {
                            // Bottom ramp - slopes up toward south (positive Z)
                            // At minZ (north/top edge): height = 0
                            // At maxZ (south/bottom edge): height = platformHeight
                            const progress = (z - collider.minZ) / collider.length;
                            return Math.max(0, Math.min(collider.height, collider.height * progress));
                        }
                    }
                }
            }
            
            return 0; // Ground level
        }

        function checkCarCollisions(newX, newZ) {
            const carRadius = 3; // Collision radius for cars
            
            // Check collision with other players
            Object.keys(otherPlayers).forEach(id => {
                const other = otherPlayers[id].mesh;
                const dx = newX - other.position.x;
                const dz = newZ - other.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if(distance < carRadius * 2) {
                    // Collision detected!
                    const angle = Math.atan2(dz, dx);
                    const force = 0.5;
                    
                    // Bounce away from other car
                    carVelocity.x += Math.cos(angle) * force;
                    carVelocity.z += Math.sin(angle) * force;
                    speed *= 0.7; // Reduce speed on collision
                    
                    // Handle game mode interactions
                    if(currentGameMode === 'tag' && !otherPlayers[id].isIt) {
                        // Tag the other player
                        if(window.isIt) {
                            socket.emit('tagPlayer', id);
                        }
                    } else if(currentGameMode === 'shooting') {
                        // Just bounce in shooting mode (damage is from bullets)
                    }
                    
                    return true;
                }
            });
            
            return false;
        }

        function checkCollisions(newX, newZ, currentY) {
            if(!window.gameColliders) return { canMove: true, bounceX: 0, bounceZ: 0 };
            
            const carWidth = 2;
            const carLength = 4;
            const tolerance = 1; // Collision margin
            
            for(let collider of window.gameColliders) {
                // Check if car overlaps with collider horizontally
                const overlapX = newX + carWidth/2 > collider.minX - tolerance && 
                                 newX - carWidth/2 < collider.maxX + tolerance;
                const overlapZ = newZ + carLength/2 > collider.minZ - tolerance && 
                                 newZ - carLength/2 < collider.maxZ + tolerance;
                
                if(overlapX && overlapZ) {
                    if(collider.type === 'platform') {
                        // Check if we're trying to hit the side of the platform
                        // If car Y is below platform top, we hit the side
                        if(currentY < collider.topY - 2) {
                            // Calculate bounce direction
                            const centerX = (collider.minX + collider.maxX) / 2;
                            const centerZ = (collider.minZ + collider.maxZ) / 2;
                            
                            const dirX = newX - centerX;
                            const dirZ = newZ - centerZ;
                            
                            // Determine which side we hit
                            const absX = Math.abs(dirX);
                            const absZ = Math.abs(dirZ);
                            
                            let bounceX = 0, bounceZ = 0;
                            
                            if(absX > absZ) {
                                // Hit left or right side
                                bounceX = dirX > 0 ? 1 : -1;
                            } else {
                                // Hit front or back side
                                bounceZ = dirZ > 0 ? 1 : -1;
                            }
                            
                            return { canMove: false, bounceX, bounceZ };
                        }
                    }
                }
            }
            
            return { canMove: true, bounceX: 0, bounceZ: 0 };
        }

        function updatePhysics() {
            if (inputs.up) speed += CONFIG.acceleration;
            if (inputs.down) speed -= CONFIG.acceleration;
            speed *= CONFIG.friction;
            if (speed > CONFIG.maxSpeed) speed = CONFIG.maxSpeed;
            if (speed < -CONFIG.maxSpeed / 2) speed = -CONFIG.maxSpeed / 2;
            if (Math.abs(speed) < 0.001) speed = 0;

            if (Math.abs(speed) > 0.01) {
                const turnFactor = inputs.left ? 1 : (inputs.right ? -1 : 0);
                carHeading += turnFactor * CONFIG.turnSpeed * Math.sign(speed);
            }

            carVelocity.x = carVelocity.x * CONFIG.driftFactor + (Math.sin(carHeading) * speed) * (1 - CONFIG.driftFactor);
            carVelocity.z = carVelocity.z * CONFIG.driftFactor + (Math.cos(carHeading) * speed) * (1 - CONFIG.driftFactor);
            
            // Calculate new position
            const newX = car.position.x + carVelocity.x;
            const newZ = car.position.z + carVelocity.z;
            
            // Check car-to-car collisions
            checkCarCollisions(newX, newZ);
            
            // Check collisions with platforms
            const collision = checkCollisions(newX, newZ, car.position.y);
            
            if(collision.canMove) {
                car.position.x = newX;
                car.position.z = newZ;
            } else {
                // Bounce off
                carVelocity.x += collision.bounceX * 0.5;
                carVelocity.z += collision.bounceZ * 0.5;
                speed *= -0.3; // Reduce speed on collision
            }

            const limit = CONFIG.mapSize / 2 - 3;
            if (car.position.x > limit || car.position.x < -limit) { car.position.x = Math.sign(car.position.x)*limit; speed *= -0.5; }
            if (car.position.z > limit || car.position.z < -limit) { car.position.z = Math.sign(car.position.z)*limit; speed *= -0.5; }

            // Update car height based on ground/platform/ramp
            const targetHeight = getGroundHeight(car.position.x, car.position.z);
            car.position.y += (targetHeight - car.position.y) * 0.2; // Smooth transition

            car.rotation.set(0, carHeading, -(inputs.left ? 1 : (inputs.right ? -1 : 0)) * (speed * 0.1));
            document.getElementById('speedometer').innerText = Math.abs(Math.round(speed * 200)) + " km/h";

            if(socket) {
                const drifting = (inputs.left || inputs.right) && Math.abs(speed) > 0.4;
                socket.emit('playerMovement', { x: car.position.x, y: car.position.y, z: car.position.z, angle: carHeading, isDrifting: drifting });
            }
        }

        function updateMultiplayerCars() {
            Object.keys(otherPlayers).forEach(id => {
                const p = otherPlayers[id];
                p.mesh.position.x += (p.targetX - p.mesh.position.x) * 0.2;
                p.mesh.position.y += (p.targetY - p.mesh.position.y) * 0.2;
                p.mesh.position.z += (p.targetZ - p.mesh.position.z) * 0.2;
                p.mesh.rotation.y = p.targetAngle; 
                if (p.isDrifting) {
                    if(Math.random() < SETTINGS.smokeChance) createRemoteSmoke(p.mesh);
                }
            });
        }

        const particleGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
        
        // REMOVED SKID MARK MATERIALS AND ARRAYS HERE

        function updateEffects() {
            const isTurning = inputs.left || inputs.right;
            const isMovingFast = Math.abs(speed) > 0.4;
            
            if (isTurning && isMovingFast) {
                if (Math.random() < SETTINGS.smokeChance) createSmoke(); 
                // REMOVED SKID MARK CREATION
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.life -= 0.03; p.mesh.position.y += p.velY; p.mesh.scale.multiplyScalar(1.05); p.mesh.material.opacity = p.life * 0.4;
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
        }

        function createSmoke() { spawnSmokeAt(car.position.x, car.position.y, car.position.z, carHeading); }
        function createRemoteSmoke(mesh) { spawnSmokeAt(mesh.position.x, mesh.position.y, mesh.position.z, mesh.rotation.y); }

        function spawnSmokeAt(cx, cy, cz, heading) {
            const offsets = [{x: -1, z: -1.2}, {x: 1, z: -1.2}];
            offsets.forEach(offset => {
                const cos = Math.cos(heading); const sin = Math.sin(heading);
                const wx = offset.x * cos + offset.z * sin; const wz = -offset.x * sin + offset.z * cos;
                const p = new THREE.Mesh(particleGeo, particleMat.clone());
                p.position.set(cx + wx, cy + 0.2, cz + wz); // Use cy (car's Y position) + slight offset
                p.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(p); particles.push({ mesh: p, life: 1.0, velY: 0.05 + Math.random()*0.05 });
            });
        }

        function updateCamera() {
            const dist = CONFIG.cameraDistance; const height = CONFIG.cameraHeight;
            const cx = car.position.x - Math.sin(carHeading) * dist; const cz = car.position.z - Math.cos(carHeading) * dist;
            camera.position.x += (cx - camera.position.x) * CONFIG.cameraLerp; camera.position.z += (cz - camera.position.z) * CONFIG.cameraLerp;
            camera.position.y += (height + car.position.y - camera.position.y) * CONFIG.cameraLerp;
            camera.lookAt(car.position.x, car.position.y, car.position.z);
        }
    </script>
</body>
</html>
