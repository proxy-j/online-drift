import React, { useEffect, useRef, useState } from 'react';

export default function DriftGame() {
  const mountRef = useRef(null);
  const [speed, setSpeed] = useState(0);
  const [showLogin, setShowLogin] = useState(true);
  const [playerName, setPlayerName] = useState('');
  const [smokeAmount, setSmokeAmount] = useState(50);
  const [shadowsEnabled, setShadowsEnabled] = useState(true);

  useEffect(() => {
    // Dynamic imports
    let THREE, io;
    let scene, camera, renderer, socket;
    let car, carVelocity, inputs, particles;
    let carSpeed = 0, carHeading = 0, carPitch = 0, carVerticalVel = 0;
    let otherPlayers = {};
    let isGameActive = false;
    let dirLight;
    let myName = "Player";
    let SETTINGS = { smokeChance: 0.5, shadows: true };
    let mapObjects = []; // For collision detection
    let isAirborne = false;
    let groundHeight = 0;

    const CONFIG = {
      maxSpeed: 1.2, acceleration: 0.02, friction: 0.98, turnSpeed: 0.045,
      driftFactor: 0.94, cameraHeight: 15, cameraDistance: 25, cameraLerp: 0.1,
      mapSize: 400, gravity: 0.015, jumpBoost: 0.3
    };

    async function init() {
      // Import Three.js
      THREE = await import('https://unpkg.com/three@0.160.0/build/three.module.js');
      
      // Setup scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 60, 400);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      mountRef.current.appendChild(renderer.domElement);

      // Lighting
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemiLight.position.set(0, 100, 0);
      scene.add(hemiLight);

      dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(80, 120, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.near = 0.5;
      dirLight.shadow.camera.far = 500;
      const d = 200;
      dirLight.shadow.camera.left = -d;
      dirLight.shadow.camera.right = d;
      dirLight.shadow.camera.top = d;
      dirLight.shadow.camera.bottom = -d;
      scene.add(dirLight);

      // Create world
      createGridGround();
      createMapLayout();
      createCar();
      createCityBorder();

      carVelocity = new THREE.Vector3();
      inputs = { up: false, down: false, left: false, right: false };
      particles = [];

      // Events
      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', (e) => { if(isGameActive) handleKey(e, true); });
      document.addEventListener('keyup', (e) => { if(isGameActive) handleKey(e, false); });

      animate();
    }

    function createGridGround() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Dark asphalt base
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, 512, 512);
      
      // Grid lines
      ctx.strokeStyle = '#2a2a2a';
      ctx.lineWidth = 2;
      const gridSize = 32;
      
      for(let i = 0; i <= 512; i += gridSize) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, 512);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(512, i);
        ctx.stroke();
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(10, 10);
      
      const groundGeo = new THREE.PlaneGeometry(CONFIG.mapSize, CONFIG.mapSize);
      const groundMat = new THREE.MeshStandardMaterial({ 
        map: texture,
        roughness: 0.9, 
        metalness: 0.1 
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      mapObjects.push({
        mesh: ground,
        bounds: { minX: -CONFIG.mapSize/2, maxX: CONFIG.mapSize/2, minZ: -CONFIG.mapSize/2, maxZ: CONFIG.mapSize/2, height: 0 }
      });
    }

    function createStripedEdge(width, depth, rotation, position) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      
      const stripeWidth = 32;
      for(let i = 0; i < 256; i += stripeWidth * 2) {
        ctx.fillStyle = '#ffdd00';
        ctx.fillRect(i, 0, stripeWidth, 64);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(i + stripeWidth, 0, stripeWidth, 64);
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      
      const geo = new THREE.BoxGeometry(width, 0.3, depth);
      const mat = new THREE.MeshStandardMaterial({ map: texture });
      const edge = new THREE.Mesh(geo, mat);
      edge.position.copy(position);
      edge.rotation.y = rotation;
      edge.castShadow = true;
      edge.receiveShadow = true;
      scene.add(edge);
    }

    function createMapLayout() {
      const platformMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.7 });
      const rampMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 });
      
      const cellSize = 40;
      const platformHeight = 20;
      const rampHeight = 10;
      
      // Map layout (10x10 grid)
      const layout = [
        ['P','P','P','P','P','P','P','P','P','P'],
        ['P','P','P','P','P','P','P','P','P','P'],
        ['R','R','G','G','G','G','G','G','R','R'],
        ['R','R','G','G','G','G','G','G','R','R'],
        ['G','G','G','G','G','G','G','G','G','G'],
        ['G','G','G','G','G','G','G','G','G','G'],
        ['R','R','G','G','G','G','G','G','R','R'],
        ['R','R','G','G','G','G','G','G','R','R'],
        ['P','P','P','P','P','P','P','P','P','P'],
        ['P','P','P','P','P','P','P','P','P','P']
      ];
      
      const startX = -5 * cellSize + cellSize/2;
      const startZ = -5 * cellSize + cellSize/2;
      
      layout.forEach((row, i) => {
        row.forEach((cell, j) => {
          const x = startX + j * cellSize;
          const z = startZ + i * cellSize;
          
          if(cell === 'P') {
            // Platform
            const platform = new THREE.Mesh(
              new THREE.BoxGeometry(cellSize, platformHeight, cellSize),
              platformMat
            );
            platform.position.set(x, platformHeight/2, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            
            mapObjects.push({
              mesh: platform,
              bounds: {
                minX: x - cellSize/2, maxX: x + cellSize/2,
                minZ: z - cellSize/2, maxZ: z + cellSize/2,
                height: platformHeight
              },
              type: 'platform'
            });
            
            // Add striped edges
            if(i === 1) createStripedEdge(cellSize, 1, 0, new THREE.Vector3(x, platformHeight, z - cellSize/2));
            if(i === 8) createStripedEdge(cellSize, 1, 0, new THREE.Vector3(x, platformHeight, z + cellSize/2));
            if(j === 0) createStripedEdge(1, cellSize, Math.PI/2, new THREE.Vector3(x - cellSize/2, platformHeight, z));
            if(j === 9) createStripedEdge(1, cellSize, Math.PI/2, new THREE.Vector3(x + cellSize/2, platformHeight, z));
          }
          else if(cell === 'R') {
            // Ramp
            const rampGeo = new THREE.BoxGeometry(cellSize, 2, cellSize);
            const ramp = new THREE.Mesh(rampGeo, rampMat);
            ramp.position.set(x, rampHeight/2, z);
            
            // Rotate ramp based on position
            if(i === 2 || i === 3) {
              ramp.rotation.x = -Math.PI / 12;
              ramp.position.y = rampHeight/2 - 2;
            } else if(i === 6 || i === 7) {
              ramp.rotation.x = Math.PI / 12;
              ramp.position.y = rampHeight/2 - 2;
            }
            
            ramp.castShadow = true;
            ramp.receiveShadow = true;
            scene.add(ramp);
            
            mapObjects.push({
              mesh: ramp,
              bounds: {
                minX: x - cellSize/2, maxX: x + cellSize/2,
                minZ: z - cellSize/2, maxZ: z + cellSize/2,
                height: rampHeight,
                rotation: ramp.rotation.x
              },
              type: 'ramp'
            });
            
            // Striped edges
            createStripedEdge(cellSize, 1, 0, new THREE.Vector3(x, rampHeight/2, z - cellSize/2));
            createStripedEdge(cellSize, 1, 0, new THREE.Vector3(x, rampHeight/2, z + cellSize/2));
            createStripedEdge(1, cellSize, Math.PI/2, new THREE.Vector3(x - cellSize/2, rampHeight/2, z));
            createStripedEdge(1, cellSize, Math.PI/2, new THREE.Vector3(x + cellSize/2, rampHeight/2, z));
          }
        });
      });
    }

    function createCityBorder() {
      const buildingMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.3 });
      const range = CONFIG.mapSize/2 + 30;
      
      for(let i = 0; i < 20; i++) {
        const h = 40 + Math.random() * 60;
        const w = 30;
        
        // North wall
        const building1 = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), buildingMat);
        building1.position.set(-range + i * 40, h/2, -range);
        building1.castShadow = true;
        scene.add(building1);
        
        // South wall
        const building2 = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), buildingMat);
        building2.position.set(-range + i * 40, h/2, range);
        building2.castShadow = true;
        scene.add(building2);
        
        // East wall
        const building3 = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), buildingMat);
        building3.position.set(range, h/2, -range + i * 40);
        building3.castShadow = true;
        scene.add(building3);
        
        // West wall
        const building4 = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), buildingMat);
        building4.position.set(-range, h/2, -range + i * 40);
        building4.castShadow = true;
        scene.add(building4);
      }
    }

    function createCar() {
      car = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.8, 4),
        new THREE.MeshStandardMaterial({ color: 0xff0044 })
      );
      body.position.y = 0.6;
      body.castShadow = true;
      car.add(body);
      
      const cabin = new THREE.Mesh(
        new THREE.BoxGeometry(1.8, 0.5, 2),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
      );
      cabin.position.set(0, 1.2, -0.2);
      cabin.castShadow = true;
      car.add(cabin);
      
      scene.add(car);
    }

    function handleKey(e, pressed) {
      if(e.key === 'ArrowUp') inputs.up = pressed;
      if(e.key === 'ArrowDown') inputs.down = pressed;
      if(e.key === 'ArrowLeft') inputs.left = pressed;
      if(e.key === 'ArrowRight') inputs.right = pressed;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function checkCollision() {
      let currentGround = 0;
      let currentPitch = 0;
      let onRamp = false;
      
      for(let obj of mapObjects) {
        const b = obj.bounds;
        if(car.position.x >= b.minX && car.position.x <= b.maxX &&
           car.position.z >= b.minZ && car.position.z <= b.maxZ) {
          
          if(obj.type === 'platform') {
            if(car.position.y < b.height + 2 && carVerticalVel <= 0) {
              currentGround = b.height;
              isAirborne = false;
            }
          } else if(obj.type === 'ramp') {
            onRamp = true;
            currentPitch = b.rotation || 0;
            const rampProgress = (car.position.z - b.minZ) / (b.maxZ - b.minZ);
            currentGround = b.height * rampProgress;
          }
        }
      }
      
      groundHeight = currentGround;
      carPitch = currentPitch;
      
      return onRamp;
    }

    function updatePhysics() {
      if (inputs.up) carSpeed += CONFIG.acceleration;
      if (inputs.down) carSpeed -= CONFIG.acceleration;
      carSpeed *= CONFIG.friction;
      if (carSpeed > CONFIG.maxSpeed) carSpeed = CONFIG.maxSpeed;
      if (carSpeed < -CONFIG.maxSpeed / 2) carSpeed = -CONFIG.maxSpeed / 2;
      if (Math.abs(carSpeed) < 0.001) carSpeed = 0;

      if (Math.abs(carSpeed) > 0.01) {
        const turnFactor = inputs.left ? 1 : (inputs.right ? -1 : 0);
        carHeading += turnFactor * CONFIG.turnSpeed * Math.sign(carSpeed);
      }

      carVelocity.x = carVelocity.x * CONFIG.driftFactor + (Math.sin(carHeading) * carSpeed) * (1 - CONFIG.driftFactor);
      carVelocity.z = carVelocity.z * CONFIG.driftFactor + (Math.cos(carHeading) * carSpeed) * (1 - CONFIG.driftFactor);
      
      car.position.x += carVelocity.x;
      car.position.z += carVelocity.z;

      // Gravity and collision
      const onRamp = checkCollision();
      
      if(car.position.y > groundHeight + 0.5) {
        isAirborne = true;
        carVerticalVel -= CONFIG.gravity;
      } else {
        if(isAirborne && Math.abs(carSpeed) > 0.8) {
          carVerticalVel = CONFIG.jumpBoost; // Little jump
        } else {
          carVerticalVel = 0;
          car.position.y = groundHeight;
          isAirborne = false;
        }
      }
      
      car.position.y += carVerticalVel;
      if(car.position.y < 0) car.position.y = 0;

      // Boundaries
      const limit = CONFIG.mapSize / 2 - 3;
      if (car.position.x > limit || car.position.x < -limit) {
        car.position.x = Math.sign(car.position.x) * limit;
        carSpeed *= -0.5;
      }
      if (car.position.z > limit || car.position.z < -limit) {
        car.position.z = Math.sign(car.position.z) * limit;
        carSpeed *= -0.5;
      }

      car.rotation.set(
        carPitch,
        carHeading,
        -(inputs.left ? 1 : (inputs.right ? -1 : 0)) * (carSpeed * 0.1)
      );

      setSpeed(Math.abs(Math.round(carSpeed * 200)));
    }

    function updateCamera() {
      const dist = CONFIG.cameraDistance;
      const height = CONFIG.cameraHeight + car.position.y;
      const cx = car.position.x - Math.sin(carHeading) * dist;
      const cz = car.position.z - Math.cos(carHeading) * dist;
      
      camera.position.x += (cx - camera.position.x) * CONFIG.cameraLerp;
      camera.position.z += (cz - camera.position.z) * CONFIG.cameraLerp;
      camera.position.y += (height - camera.position.y) * CONFIG.cameraLerp;
      camera.lookAt(car.position.x, car.position.y + 2, car.position.z);
    }

    function animate() {
      requestAnimationFrame(animate);
      if(isGameActive && car) {
        updatePhysics();
        updateCamera();
      }
      if(renderer && scene && camera) {
        renderer.render(scene, camera);
      }
    }

    init();

    // Handle login
    window.startDriftGame = () => {
      if(playerName.trim() !== '') {
        myName = playerName;
        setShowLogin(false);
        isGameActive = true;
      }
    };

    return () => {
      if(renderer && mountRef.current) {
        mountRef.current.removeChild(renderer.domElement);
      }
    };
  }, [playerName]);

  return (
    <div style={{ width: '100%', height: '100vh', position: 'relative' }}>
      {showLogin && (
        <div style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          background: 'rgba(0,0,0,0.85)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 10
        }}>
          <div style={{
            background: '#fff',
            padding: '30px',
            borderRadius: '10px',
            textAlign: 'center',
            boxShadow: '0 0 20px rgba(0,0,0,0.5)'
          }}>
            <h1>Drift City</h1>
            <p>Enter your racer name:</p>
            <input
              type="text"
              value={playerName}
              onChange={(e) => setPlayerName(e.target.value)}
              placeholder="Your Name"
              maxLength={10}
              style={{
                padding: '10px',
                fontSize: '1.2rem',
                width: '200px',
                marginBottom: '15px',
                border: '2px solid #ccc',
                borderRadius: '5px'
              }}
            />
            <br />
            <button
              onClick={() => window.startDriftGame()}
              style={{
                padding: '10px 20px',
                fontSize: '1.2rem',
                background: '#ff0044',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer'
              }}
            >
              JOIN GAME
            </button>
          </div>
        </div>
      )}

      <div style={{
        position: 'absolute',
        bottom: '20px',
        left: '20px',
        color: '#fff',
        fontSize: '2.5rem',
        fontFamily: 'monospace',
        fontWeight: 'bold',
        textShadow: '2px 2px 0px #000',
        zIndex: 5
      }}>
        {speed} km/h
      </div>

      <div style={{
        position: 'absolute',
        top: '20px',
        right: '20px',
        width: '200px',
        background: 'rgba(0,0,0,0.7)',
        color: 'white',
        padding: '15px',
        borderRadius: '10px',
        fontSize: '0.9rem',
        zIndex: 5
      }}>
        <h3 style={{ marginTop: 0, borderBottom: '1px solid #555', paddingBottom: '5px' }}>
          Performance
        </h3>
        <div style={{ marginBottom: '15px' }}>
          <label style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}>
            Smoke Amount <span style={{ fontSize: '0.8rem', color: '#aaa', float: 'right' }}>{smokeAmount}%</span>
          </label>
          <input
            type="range"
            min="0"
            max="100"
            value={smokeAmount}
            onChange={(e) => setSmokeAmount(e.target.value)}
            style={{ width: '100%' }}
          />
        </div>
        <div style={{ marginBottom: '15px' }}>
          <label style={{ display: 'flex', justifyContent: 'space-between', cursor: 'pointer' }}>
            Shadows
            <input
              type="checkbox"
              checked={shadowsEnabled}
              onChange={(e) => setShadowsEnabled(e.target.checked)}
            />
          </label>
        </div>
        <div style={{ fontSize: '0.7rem', color: '#888', marginTop: '10px' }}>
          Use arrow keys to drive. Hit ramps at speed to jump!
        </div>
      </div>

      <div ref={mountRef} style={{ width: '100%', height: '100%' }} />
    </div>
  );
}
