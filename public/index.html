<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Drift</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: white; pointer-events: none; text-shadow: 2px 2px 4px black;
            font-size: 1.5rem; font-weight: bold;
        }
        #speedometer {
            position: absolute; bottom: 20px; right: 20px; color: #fff;
            font-size: 2.5rem; font-family: monospace; font-weight: bold;
            text-shadow: 2px 2px 0px #000;
        }
    </style>
</head>
<body>

    <div id="info">Multiplayer Drift - Share the link to play!</div>
    <div id="speedometer">0 km/h</div>

    <script src="/socket.io/socket.io.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Config ---
        const CONFIG = {
            maxSpeed: 1.2, acceleration: 0.02, friction: 0.98, turnSpeed: 0.045,
            driftFactor: 0.94, cameraHeight: 15, cameraDistance: 25, cameraLerp: 0.1,
            mapSize: 400
        };

        // --- Globals ---
        let scene, camera, renderer, socket;
        let car, carVelocity = new THREE.Vector3();
        let inputs = { up: false, down: false, left: false, right: false };
        let particles = [];
        let skidMarks = [];
        let speed = 0;
        let carHeading = 0;
        let otherPlayers = {}; 
        
        const dummyObj = new THREE.Object3D(); 

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 60, 300);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 100, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(80, 120, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024; 
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 400;
            const d = 150;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            scene.add(dirLight);

            createParkingLot();
            createCityBorderOptimized();
            createCar();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => handleKey(e, true));
            document.addEventListener('keyup', (e) => handleKey(e, false));

            initSocket();
        }

        function initSocket() {
            socket = io();

            socket.on('currentPlayers', (players) => {
                Object.keys(players).forEach((id) => {
                    if (id !== socket.id) addOtherPlayer(players[id], id);
                });
            });

            socket.on('newPlayer', (data) => {
                addOtherPlayer(data.player, data.id);
            });

            socket.on('playerMoved', (data) => {
                if (otherPlayers[data.id]) {
                    otherPlayers[data.id].targetX = data.x;
                    otherPlayers[data.id].targetZ = data.z;
                    otherPlayers[data.id].targetAngle = data.angle;
                    otherPlayers[data.id].isDrifting = data.isDrifting; 
                }
            });

            socket.on('playerDisconnected', (id) => {
                if (otherPlayers[id]) {
                    scene.remove(otherPlayers[id].mesh);
                    delete otherPlayers[id];
                }
            });
        }

        function addOtherPlayer(data, id) {
            const playerGroup = new THREE.Group();
            
            const bodyGeo = new THREE.BoxGeometry(2, 0.8, 4);
            const bodyMat = new THREE.MeshStandardMaterial({ color: data.color || 0xcccccc });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            playerGroup.add(body);

            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.5, 2),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            cabin.position.set(0, 1.2, -0.2);
            playerGroup.add(cabin);

            playerGroup.position.set(data.x, 0, data.z);
            scene.add(playerGroup);

            otherPlayers[id] = {
                mesh: playerGroup,
                targetX: data.x,
                targetZ: data.z,
                targetAngle: data.angle,
                isDrifting: false
            };
        }

        function createParkingLot() {
            const groundGeo = new THREE.PlaneGeometry(CONFIG.mapSize, CONFIG.mapSize);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const lineGeo = new THREE.PlaneGeometry(0.5, 10);
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
            const parkingLines = new THREE.InstancedMesh(lineGeo, lineMat, 400);
            parkingLines.instanceMatrix.setUsage(THREE.StaticDrawUsage);
            
            let index = 0;
            const rows = 4, cols = 10;
            for(let r = -rows; r <= rows; r++) {
                if (r === 0) continue; 
                for(let c = -cols; c <= cols; c++) {
                    if(Math.random() > 0.1 && index < 400) {
                        dummyObj.position.set(c * 15, 0.02, r * 40);
                        dummyObj.rotation.set(-Math.PI/2, 0, 0);
                        dummyObj.scale.set(1, 1, 1);
                        dummyObj.updateMatrix();
                        parkingLines.setMatrixAt(index++, dummyObj.matrix);
                    }
                }
            }
            scene.add(parkingLines);
        }

        function createCityBorderOptimized() {
            const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
            const buildingMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.2 });
            const buildings = new THREE.InstancedMesh(buildingGeo, buildingMat, 200);
            buildings.castShadow = true; buildings.receiveShadow = true;

            let idx = 0;
            const range = CONFIG.mapSize/2 + 20;
            const countPerWall = Math.ceil(CONFIG.mapSize / 40) + 2;

            const addWall = (sx, sz, dx, dz) => {
                for(let i=0; i<countPerWall; i++) {
                    const h = 40 + Math.random() * 80;
                    dummyObj.position.set(sx + (i*dx*40), h/2, sz + (i*dz*40));
                    dummyObj.rotation.set(0,0,0);
                    dummyObj.scale.set(40, h, 40);
                    dummyObj.updateMatrix();
                    buildings.setMatrixAt(idx++, dummyObj.matrix);
                }
            };
            addWall(-range, -range, 1, 0); addWall(-range, range, 1, 0);
            addWall(range, -range, 0, 1); addWall(-range, -range, 0, 1);
            scene.add(buildings);
        }

        function createCar() {
            car = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4), new THREE.MeshStandardMaterial({ color: 0xff0044 }));
            body.position.y = 0.6; body.castShadow = true; car.add(body);
            
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            cabin.position.set(0, 1.2, -0.2); cabin.castShadow = true; car.add(cabin);

            const wGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[-1,0.4,1.2],[1,0.4,1.2],[-1,0.4,-1.2],[1,0.4,-1.2]].forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI/2; w.position.set(...p); w.castShadow = true; car.add(w);
            });

            const lightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            const l = new THREE.Mesh(lightGeo, lightMat); l.position.set(-0.6, 0.7, 2.0); car.add(l);
            const r = new THREE.Mesh(lightGeo, lightMat); r.position.set(0.6, 0.7, 2.0); car.add(r);

            scene.add(car);
        }

        function handleKey(e, pressed) {
            if(e.key === 'ArrowUp') inputs.up = pressed;
            if(e.key === 'ArrowDown') inputs.down = pressed;
            if(e.key === 'ArrowLeft') inputs.left = pressed;
            if(e.key === 'ArrowRight') inputs.right = pressed;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateMultiplayerCars();
            updateEffects();
            updateCamera();
            renderer.render(scene, camera);
        }

        function updatePhysics() {
            if (inputs.up) speed += CONFIG.acceleration;
            if (inputs.down) speed -= CONFIG.acceleration;
            speed *= CONFIG.friction;
            if (speed > CONFIG.maxSpeed) speed = CONFIG.maxSpeed;
            if (speed < -CONFIG.maxSpeed / 2) speed = -CONFIG.maxSpeed / 2;
            if (Math.abs(speed) < 0.001) speed = 0;

            if (Math.abs(speed) > 0.01) {
                const turnFactor = inputs.left ? 1 : (inputs.right ? -1 : 0);
                carHeading += turnFactor * CONFIG.turnSpeed * Math.sign(speed);
            }

            const forwardX = Math.sin(carHeading);
            const forwardZ = Math.cos(carHeading);
            const currentVelX = carVelocity.x;
            const currentVelZ = carVelocity.z;
            const targetVelX = forwardX * speed;
            const targetVelZ = forwardZ * speed;

            carVelocity.x = currentVelX * CONFIG.driftFactor + targetVelX * (1 - CONFIG.driftFactor);
            carVelocity.z = currentVelZ * CONFIG.driftFactor + targetVelZ * (1 - CONFIG.driftFactor);

            car.position.x += carVelocity.x;
            car.position.z += carVelocity.z;

            const limit = CONFIG.mapSize / 2 - 3;
            if (car.position.x > limit || car.position.x < -limit) { car.position.x = Math.sign(car.position.x)*limit; speed *= -0.5; }
            if (car.position.z > limit || car.position.z < -limit) { car.position.z = Math.sign(car.position.z)*limit; speed *= -0.5; }

            const lean = (inputs.left ? 1 : (inputs.right ? -1 : 0)) * (speed * 0.1);
            car.rotation.set(0, carHeading, -lean);

            document.getElementById('speedometer').innerText = Math.abs(Math.round(speed * 200)) + " km/h";

            if(socket) {
                const isTurning = inputs.left || inputs.right;
                const isMovingFast = Math.abs(speed) > 0.4;
                const drifting = isTurning && isMovingFast;
                
                socket.emit('playerMovement', {
                    x: car.position.x,
                    z: car.position.z,
                    angle: carHeading,
                    isDrifting: drifting
                });
            }
        }

        function updateMultiplayerCars() {
            Object.keys(otherPlayers).forEach(id => {
                const p = otherPlayers[id];
                p.mesh.position.x += (p.targetX - p.mesh.position.x) * 0.2;
                p.mesh.position.z += (p.targetZ - p.mesh.position.z) * 0.2;
                p.mesh.rotation.y = p.targetAngle; 

                if (p.isDrifting) {
                    createRemoteSmoke(p.mesh);
                    createRemoteSkids(p.mesh, p.targetAngle);
                }
            });
        }

        const particleGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
        const skidGeo = new THREE.PlaneGeometry(0.4, 0.4);
        const skidMat = new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });

        function updateEffects() {
            const isTurning = inputs.left || inputs.right;
            const isMovingFast = Math.abs(speed) > 0.4;
            if (isTurning && isMovingFast) {
                if (Math.random() > 0.5) createSmoke(); 
                createSkidMarks();
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.03; 
                p.mesh.position.y += p.velY;
                p.mesh.scale.multiplyScalar(1.05); 
                p.mesh.material.opacity = p.life * 0.4;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            if (skidMarks.length > 300) { const old = skidMarks.shift(); scene.remove(old.mesh); }
            for (let i = skidMarks.length - 1; i >= 0; i--) {
                const s = skidMarks[i];
                s.life -= 0.005; 
                s.mesh.material.opacity = s.life * 0.3;
                if (s.life <= 0) { scene.remove(s.mesh); skidMarks.splice(i, 1); }
            }
        }

        function createSmoke() { spawnSmokeAt(car.position.x, car.position.z, carHeading); }
        function createRemoteSmoke(mesh) { 
            if (Math.random() > 0.5) spawnSmokeAt(mesh.position.x, mesh.position.z, mesh.rotation.y); 
        }

        function spawnSmokeAt(cx, cz, heading) {
            const offsets = [{x: -1, z: -1.2}, {x: 1, z: -1.2}];
            offsets.forEach(offset => {
                const cos = Math.cos(heading);
                const sin = Math.sin(heading);
                const wx = offset.x * cos + offset.z * sin;
                const wz = -offset.x * sin + offset.z * cos;
                const p = new THREE.Mesh(particleGeo, particleMat.clone());
                p.position.set(cx + wx, 0.2, cz + wz);
                p.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(p);
                particles.push({ mesh: p, life: 1.0, velY: 0.05 + Math.random()*0.05 });
            });
        }

        function createSkidMarks() { spawnSkidsAt(car.position.x, car.position.z, carHeading); }
        function createRemoteSkids(mesh, heading) { spawnSkidsAt(mesh.position.x, mesh.position.z, heading); }

        function spawnSkidsAt(cx, cz, heading) {
            const offsets = [{x: -1, z: -1.2}, {x: 1, z: -1.2}];
            offsets.forEach(offset => {
                const cos = Math.cos(heading);
                const sin = Math.sin(heading);
                const wx = offset.x * cos + offset.z * sin;
                const wz = -offset.x * sin + offset.z * cos;
                const skid = new THREE.Mesh(skidGeo, skidMat.clone());
                skid.rotation.x = -Math.PI / 2;
                skid.position.set(cx + wx, 0.05, cz + wz);
                scene.add(skid);
                skidMarks.push({ mesh: skid, life: 1.0 });
            });
        }

        function updateCamera() {
            const dist = CONFIG.cameraDistance;
            const height = CONFIG.cameraHeight;
            const cx = car.position.x - Math.sin(carHeading) * dist;
            const cz = car.position.z - Math.cos(carHeading) * dist;
            camera.position.x += (cx - camera.position.x) * CONFIG.cameraLerp;
            camera.position.z += (cz - camera.position.z) * CONFIG.cameraLerp;
            camera.position.y += (height + car.position.y - camera.position.y) * CONFIG.cameraLerp;
            camera.lookAt(car.position.x, car.position.y, car.position.z);
        }
    </script>
</body>
</html>
